# :page_with_curl:图
[:clock1:图的定义和术语](#one图的定义和术语)|[:clock2:图的存储结构](#two图的存储结构)|[:clock3:图的遍历](#three图的遍历)|[:clock4:图的应用](#four图的应用)
---|---|---|---|
## :one:图的定义和术语
<details>
<summary>

**图的定义**</summary>
* 图
  * G=(V,E)
  * V：顶点（数据元素）的`有穷非空`集合
  * E：边的`有穷`集合
</details>
<details>
<summary>

**术语**</summary>
* 无向图
  * 每条边都是无方向的
* 有向图
  * 每条边都是有方向的
* 完全图
  * 任意两个点都有一条边相连
  * 无向完全图，n(n-1)/2条边 ==Cn2==
  * 有向完全图，n(n-1)条边
* 稀疏图
  * 有很少边或弧的图（e<nlogn）
* 稠密图
  * 有较多边或弧的图
* 网
  * 边/弧带权的图
* 邻接
  * 有边/弧相连的两个顶点之间的关系
  * 存在(vi,vj)，则称vi和vj互为`邻接点`
  * 存在<vi,vj>，则称vi`邻接到`vj,vj`邻接与`vi
* 关联（依附）
  * 边/弧与顶点之间的关系
  * 存在(vi,vj)/<vi,vj>，则称该边/弧关联于vi和vj
* 顶点的度
  * 与该顶点相关联的边的数目，记为TD(v)
  * 在`有向图`中，顶点的度等于该顶点的`入度`和`出度`之和
  * 顶点`v的入度`是以v为终点的有向边的条数，记作ID(v)
  * 顶点`v的出度`是以v为始点的有向边的条数，记作OD(v)
    >当有向图中仅1个顶点的入度为0，其余顶点的入度均为1,此时是何形状？
    >>是树！且是一颗有向树！
* 路径
  * 接续的边构成的顶点序列
* 路径长度
  * 路径上边或弧的数目/权值之和
* 回路（环）
  * 第一个顶点和最后一个顶点相同的路径
* 简单路径
  * 除路径起点和路径终点可以相同外，其余顶点均不相同的路径
* 简单回路（简单环）
  * 除路径起点和终点相同外，其余顶点均不相同的路径
* 连通图（强连通图）
  * 在无（有）向图G={V,{E}}中，若对任何两个顶点v、u都存在从v到u的路径，则称G是连通图（强连通图）
* 权与网
  * 图中边或弧所具有的相关数称为权。表明一个顶点到另一个顶点的距离或耗费
  * 带权的图称为网
* 子图
  * 设有两个图G={G，{E}}、G1={V1，{E1}}，若V1是V的子集，E1是E的子集，则称G1是G的子图
* 连通分量（强连通分量）
  * 无向图G的`极大连通子图`称为G的连通分量
    * `极大连通子图`：该子图是G连通子图，将G的任何不在该子图中的顶点加入，子图不在连通
  * 有向图G的`极大强连通子图`称为G的强连通分量
    * `极大强连通子图`：该子图是G的强连通子图，将D的任何不在该子图中的顶点加入，子图不再是强连通的
* 极小连通子图
  * 该子图是G的连通子图，在该子图中删除任何一条边，子图不在连通
* 生成树
  * 包含无向图G所有顶点的极小连通子图
* 生成森林
    * 对非连通图，由各个连通分量的生成的树的集合
</details>

## :two:图的存储结构
<details>
<summary>

**邻接矩阵**</summary>
* 建立一个`顶点表`（记录各个顶点的信息）和一个`邻接矩阵`（表示各个顶点之间的关系）
* 设图A=(V,E)有n个顶点则，顶点表`Vexs[n]`
* 图的邻接矩阵是一个二维数组`A.arxs[n][n]`,定义为
  * A.arcs[i][j]=
    * 1,如果<i,j>属于E或者(i,j)属于E
    * 0，否则
  >分析1：无向图的邻接矩阵是`对称`的
  分析2：顶点的`度`=第i行（列）中`1`的个数
  特别：完全图的邻接矩阵中，对角元素为0，其余1
****
* 有向图的邻接表示法
  * 在有向图的邻接矩阵中
    * 第i行的含义：以结点vi为尾的弧（即出度边）
    * 第i列的含义：以结点vi为头的弧（即入度边）
  >分析1：有向图的邻接矩阵`可能是不对称`的
  分析2：顶点的`出度=第i行元素之和`
  顶点的`入度=第i列元素之和`
  顶点的度=第i行元素之和+第i列元素之和
* 网（即有权图）的邻接矩阵表示法
  * A.arcs[i][j]=
    * wij ，<vi,vj>或(vi,vj)属于VR
    * 无穷 ，无边（弧）
</details>
<details>
<summary>

**邻接矩阵的存储表示**</summary>
* 用`两个数组`分别存储`顶点表`和`邻接矩阵`
  ```c
  #define Maxint 32767     // 表示极大值
  #define MVNum 100        // 最大顶点数
  typedef char VerTexType; // 设顶点的数据类型为字符型
  typedef int ArcType;     // 假设边的权值类型为整型
  typedef struct
  {
      VerTexType vexs[MVNum];     // 顶点表
      ArcType arcs[MVNum][MVNum]; // 邻接矩阵
      int vexnum, arcnum;         // 图的当前点数和边数
  } AMGraph;
  ```
* 创建无向网的算法思想
  * 输入总顶点数和总边数
  * 依次输入点的信息存入顶点表中
  * 初始化矩阵，使每个权值初始化为最大值
  * 构造邻接矩阵
  ```c
  Status CreateUDN(AMGraph &G)
  {
      cin >> G.vexnum >> G.arcnum; // 输入总顶点数，总边数
      for (int i = 0; i < G.vexnum; i++)
          cin >> G.vexs[i]; // 依次输入点的信息
      for (int i = 0; i < G.vexnum; i++)
          for (int j = 0; j < G.vexnum; j++)
              G.arcs[i][j] = Maxint;     // 边的权值初始化极大值
      for (int k = 0; k < G.arcnum; k++) // 构造邻接矩阵
      {
          cin >> v1 >> v2 >> w; // 输入一条边所依附的顶点及边的权值
          int i = LocateVex(G, v1);
          int j = Locatevex(G, v2);    // 确定v1和v2在G中的位置
          G.arcs[i][j] = w;            // 边<v1,v2>的权值置为w
          G.arcs[j][i] = G.arcs[i][j]; // 利用对称性
      }
      return OK;
  }  
  int LocateVex(AMGraph G, VertexType u)
  {
      int i;
      for (int i = 0; i < G.vexnum; i++)
          if (u == G.vexs[i])
              return i;
      return -1;
  }
  ```
  * 由创建无向网类比无向图和有向网
    * 无向图 
      * 初始化邻接矩阵时，w为0
      * 构造邻接矩阵时，w为1
    * 有向网
      * 邻接矩阵是非对称矩阵
      * 仅为G.arcs[i][j]赋值
      * 无需为G.arcs[j][i]赋值
</details>
<details>
<summary>

**邻接矩阵的优缺点**</summary>
* 优点
  * 直观、简单、好理解
  * 方便检查任意一对顶点间是否存在边 
  * 方便找任一顶点的所有"邻接点"（有边直接相连的矩阵）
  * 方便计算任一顶点的"度"（从该点出发的边为"出度"，指向该点的边数为"入度"）
    * 无向图：对应行（或列）非0元素的个数
    * 有向图：对应行非0元素的个数是"出度"；对应列非0元素的个数是"入度"
* 缺点
    * 不便于增加和删除顶点
    * 浪费空间——存储稀疏图（点很多而边很少）有大量无效元素
      * 对稠密图（特别是完全图）还是很合算的
    * 浪费时间——统计稀疏图一共有多少条边
</details>
<details>
<summary>

**邻接表**</summary>
* 顶点：按编号顺序将顶点数据存储在`一维数组`中；
* 关联同一顶点的边（以顶点为尾的弧）
  * 用线性链表存储
* 特点
  * 邻接表不唯一
  * 若`无向图`中有n个顶点、e条边，则邻接表需n个头结点和2e个表结点。适宜存储稀疏图
  * `无向图`中顶点vi的度为第i个链表中的结点数
****
* 有向图
  * 邻接表
    * 顶点vi的`出度`为第i个单链表中的结点个数
    * 顶点vi的`入度`为整个单链表中邻点域值是i-1的结点个数
  * 逆邻接表
    * 顶点vi的`入度`为第i个单链表中的结点个数
    * 顶点vi的`出度`为整个单链表中邻点域值是i-1的结点个数
  > 邻接表找出度容易，找入度难
  > 逆邻接表入度容易，找出度难
</details>
<details>
<summary>

**邻接表的存储表示**</summary>
* 顶点的结点结构
  ```c
  typedef struct VNode
  {
      VerTexType data;     // 顶点信息
      ArcNode *firstarc;   // 指向第一条依附该顶点的边的指针
  } VNode, AdjList[MVNum]; // AdjList表示邻接表类型
  // AdjList v ; 相当于 VNode v[MUNum];
  ```
* 边的结点结构
  ```c
  #define MVNum 100 // 最大顶点数
  typedef struct ArcNode
  {
      int adjevex;             // 该边所指的顶点的位置
      struct ArcNode *nextarc; // 指向下一条边的指针
      OtherInfo info;          // 和边的相关信息
  };
  ```
* 图的结构定义
  ```c
  typedef struct ALGraph
  {
      AdjList vertices;   // vertices--vertex的复数
      int vexnum, arcnum; // 图的当前顶点数和弧数
  }
  ```
* 邻接表表示法创建无向网
  * 算法思想
    * 输入`总顶点数`和`总边数`
    * 建立`顶点表`
      * 依次输入点的信息存入顶点表中
      * 使每个表头结点的指针域初始化为NULL 
    * 创建`邻接表`
      * 依次输入每条边依附的两个顶点
      * 确定两个顶点的序号i和j，建立边结点
      * 将此边结点分别插入到vi和vj对应的两个边链表的头部
  ```c
  Status CreateUDG(ALGraph &G)
  {
      cin >> G.vexnum >> G.arcnum;       // 输入总顶点数，总边数
      for (int i = 0; i < G.vexnum; i++) // 输入各点，构造表头结点表
      {
          cin >> G.vertices[i].data;     // 输入顶点值
          G.vertices[i].firstarc = NULL; // 初始化表头结点的指针域
      }                                  // for
      for (int k = 0; k < G.arcnum; k++)
      {
          cin >> v1 >> v2; // 输入一条边依附的两个顶点
          i = LocateVex(G, v1);
          j = LocateVex(G, v2);
          p1 = new ArcNode; // 生成一个新的边结点*p1
          p1->adjvex = j;   // 邻结点序号为j
          p1->nextarc = G.vertices[i].firstarc;
          G.vertices[i].firstarc = p1; // 将新结点*p1插入顶点vi的边表头部
          p2 = new ArcNode;            // 生成另一个对称的新的边结点*p2
          p2->adjevex = i;             // 邻接点序号为i
          p2->nextarc = G.vertices[j].firstarc;
          G.vertices[j].firstarc = p2; // 将新结点*p2插入顶点vj的边表头部
      }                                // for
      return OK;
  }
  ```
  </details>
<details>
<summary>

**邻接表表示法优缺点及与邻接矩阵的关系**</summary>
* 邻接表特点
  * 方便找任一顶点的所有`邻接点`
  * 节约稀疏图的空间
    * 需要N个头指针+2E个结点（每个结点至少2个域）
  * 方便计算任一顶点的度
    * 对无向图：是的
    * 对有向图：只能计算`出度`；需要构造`逆邻接表`（存指向自己的边）来方便计算`入度`
  * 不方便检查任意一对顶点间是否存在边
  </details>
<details>
<summary>

**邻接矩阵与邻接表表示法的关系**</summary>
* 联系
  * 邻接表中每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数
* 区别
  * 对于任一确定的无向图，邻接矩阵是`唯一`的（行列号与顶点编号一致），但邻接表`不唯一`（链接次序与顶点编号无关）
  * 邻接矩阵的空间复杂度为`O(n^2)`,而邻接表的空间复杂度为`O(n+e)`
* 用途
  * 邻接矩阵多用于`稠密图`；而邻接表多用于`稀疏图`
  </details>
<details>
<summary>

**十字链表**</summary>
>邻接表->有向图->缺点：求结点的度困难->十字链表
* 十字链表
  * 十字链表是有向图的一种链式存储结构。我们也可以把他看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表
* 有向图中的每一条弧对应的十字链表中的一个`弧结点`，同时有向图中的每个顶点在十字链表中对应有一个结点，叫做`顶点结点`
  </details>
<details>
<summary>

**邻接多重表**</summary>
>邻接表->无向图->缺点：每条边都要存储两遍->邻接多重表
邻接表删除一条边需找表示此边的两个顶点
 </details>

## :three:图的遍历
<details>
<summary>

**遍历定义**</summary>
  * 从已给的连通图中某一顶点出发，沿着一些边访问图中所有的顶点，且使每个顶点仅被访问一次，就叫做`图的遍历`，他是图的基本运算
  * 遍历实质：找每个顶点的邻接点的过程
</details>
<details>
<summary>

**图的特点**</summary>
* 图中可能存在`回路`，且图的任一顶点都可能与其他顶点想通，在访问完某个顶点之后可能会沿着某些边`又回到了曾经访问过的顶点`
* 怎样避免重复访问
  * 设置辅助数组`visited[n]`，用来标记每个被访问过的顶点
    * 初始状态visited[i]为0
    * 顶点i被访问，改visited[i]为1，防止被多次访问
</details>
<details>
<summary>

**图常用的遍历**</summary>
* 深度优先搜索（Depth_First Search——DFS）
* 广度优先搜索（Breadth_First Search——BFS）
</details>
<details>
<summary>

**遍历算法**</summary>
* 采用`邻接矩阵`表示图的深度优先搜索遍历
  ```c
  void DFS(AMGraph G, int v)
  {
      cout << v; // 访问第v个顶点
      visited[v] = true;
      for (int w = 0; w < G.vexnum; w++) // 依次检查邻接矩阵v所在的行
      {
          if ((G.arcs[v][w] != 0) && (!visited[w]))
              DFS(G, w); // w是v的邻结点，如果w未访问，则递归调用DFS
      }
  }
  ```
  * 用`邻接矩阵`来表示图，遍历图中每一个顶点都要从头扫描该顶点所在行，时间复杂度为`O(n^2)`
  * 用`邻接表`来表示图，虽然有2e个表结点，单只需扫描e个结点即可完成遍历，加上访问n个头结点的时间，时间复杂度为`O(n+e)`
    >结论：
    稠密图适于在邻接矩阵上进行深度遍历
    稀疏图适于在邻接表上进行深度遍历 
* 采用`邻接表`表示图的广度优先搜索遍历
  ```c
  void BFS(Graph G, int v) // 按广度优先非递归遍历连通图G
  {
      cout << v;
      visited[v] = true; // 访问第v个顶点
      InitQueue(Q);      // 辅助队列Q初识化，置空
      EnQueue(Q, v);     // v进队
      while (!QueueEmpty(Q))
      {
          DeQueue(Q, u); // 队头元素出队并置为u
          for (w = FirstAdjVEX(G, u); W >= 0; w = NextAdjVex(G, u, w))
          {
              if (!visited[w]) // w为u的尚未访问的邻接顶点
              {
                  cout << w;
                  visited[w] = true;
                  EnQueue(Q, w); // w进队
              }
          }
      }
  }
  ```
  * 如果使用邻接矩阵，则BFS对于每一个被访问到的顶点，都要循环检测矩阵中的整整一行（n个元素），总的时间代价为`O(n^2)`
  * 用邻接表来表示图，虽然有2e个表结点，但只需要扫描e个结点即可完成遍历，加上访问n个头结点的时间，时间复杂度为`O(n+e)`
</details>

## :four:图的应用
<details>
<summary>

**最小生成树**</summary>
* 生成树
  * 所有顶点均由边连接在一起，但`不存在回路`的图
  * 一个图可以有许多棵不同的生成树
  * 所有生成树具有以下共同特点
    * 生成树的顶点个数与图的`顶点个数相同`
    * 生成树具有以下共同特点
      * 生成树的顶点个数与图的`顶点个数相同`
      * 生成树是图的`极小连通子图`，去掉一条边则非连通
      * 一个有n个顶点的连通图的生成树有`n-1`条边
      * `在生成树中在加一条边必然形成回路`
      * 生成树中任意两个顶点间的`路径是唯一`的
* 无向图的生成树
  * 深度优先生成树
  * 广度优先生成树
* 最小生成树
  * 给定一个无向网络，在该网的所有生成树中，使得`各边权值之和最小`的那棵生成树称为该网的`最小生成树`，也叫最小代价生成树
* 构造最小生成树（Minimum Spanning Tree）
  * MST性质：设N=(V,E)是一个连通网，U是顶点集V的一个非空子集。若边(u,v)是一条具有最小权值的边，其中u属于U，v属于V-U,则必存在一棵包含边(u,v)的最小生成树
    > 在生成树的构造过程中，图中n个顶点分属于两个集合
    >* 已落在生成树上的顶点集
    >* 尚未落在生成树上的顶点集 
    >接下来则在所有连通图中顶点U和V-U中顶点的边中选取`权值最小的边`    
* 构造最小生成树方法
  * 普利姆(Prim)算法
    * 设N=(V,E)是连通网，`TE`是N上的最小生成树中`边的集合`
    * 初始令U={u0},(u0属于V)，`TE={}`
    * 在所有u属于U，v属于V-U的边(u,v)属于E中，找一条代价最小的边(u0,v0)
    * 将(u0,v0)并入集合`TE`，同时v0并入U
    * 重复上述操作直至U=V为止，则T=(V,TE)为N的最小生成树
  * 克鲁斯卡尔(Kruskal)算法
    * 设连通网N=(V,E),令最小生成树初始状态为`只有`n个`顶点`而非`无边`的非连通图T=(V,{}),每个顶点自成一个连通分量
    * 在E中选取代价最小的边，若该边依附的顶点落在T中不同的连通分量上（即：`不能形成环`），则将此边加入到T中，否则，舍去此边，选取下一条代价最小的边
    * 依次类推，直至T中所有顶点都在同一连通分量上为止
      >最小生成树可能不唯一
  * 两种算法比较

    算法名|普利姆算法|克鲁斯卡尔算法
    ---|---|---|
    算法思想|选择点|选择边
    时间复杂度|O(n^2)|O(eloge)(e为边数)
    适应范围|稠密图|稀疏图
</details>
<details>
<summary>

**最短路径**</summary>
* 单元最短路径——Dijkstra算法（迪杰斯特拉算法）
  * 局部找最优，不断更新——贪心算法          
* 所有顶点间的最短路径——Floyd算法（弗洛伊德算法）
  * 方法一：每次以一个顶点为原点，重复执行Dijkstra算法n次
  * 方法二：弗洛伊德算法
    * 初始时设置一个n阶方阵，令其对角线元素为0，若存在弧<vi,vj>,则对应元素为权值；否则为无穷
    * 逐步试着在原路径中增加中间顶点，若加入中间顶点后路径变短，则修改之；否则，维持原值。所有顶点试探完毕，算法结束。
</details>
<details>
<summary>

**关键路径与拓扑排序**</summary>
* 有向无环图：无环的有向图，简称`DAG图`（Directed Acycline Graph）
* AOV网——拓扑排序
  * 用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以`顶点表示活动`，`弧表示活动之间的优先制约关系`，称这种有向图为`顶点表示活动的网`，简称`AOV网（Activity On Vertex netwo）`
* AOE网——关键路径
  * 用一个有向图表示一个工程的各子工程及其相互制约的关系，以`弧表示活动`，以`顶点表示活动的开始或结束事件`，称这种有向图为`边表示活动的网`，简称为`AOE网(Activity On Edge)`
* AOV网的特点
  * 若从i到j有一条有向路径，则i是j的前驱;j是i的后继
  * 若<i,j>是网中有向边，则i是j的直接前驱；j是i的直接后继
  * AOV网中不允许有回路，因为如果有回路存在，则表明某项活动以自己为先决条件，显然这是荒谬的  
* 拓扑排序
  * 在AOV网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若AOV网中有弧<i,j>存在，则在这个序列中，i一定排在j的前面，具有这种性质的线性序列称为`拓扑有序序列`，相应的拓扑有序排序的算法称为`拓扑排序`
  * 拓扑排序的方法
    * 在有向图中选一个没有前驱的顶点且输出之
    * 从图中删除该顶点和所有以它为尾的弧
    * 重复上述两步，直至全部顶点均已输出；或者当图中不存在无前驱的结点为止
    >一个网的拓扑序列不是唯一的
  * 检测AOV网中`是否存在环`方法
    * 对有向图中构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV网中必定不存在环 
* 关键路径
  * 路径长度最长的路径
    * 路径长度——路径上各活动持续时间之和
  * 如何确定关键路径，需要定义4个描述量
    * ve(vj)——表示事件vj的最早发生时间
    * vl(vj)——表示事件vj的最迟发生时间
    * e(i)——表示活动ai的最早开始时间
    * l(i)——表示活动ai的最迟开始时间
    >l(i)-e(i)——表示完成活动ai的时间余量
    关键活动——关键路径上的活动，即l(i)==e(i)的活动
    >>如何找到l(i)==e(i)的关键活动
    设活动ai用弧<j,k>表示，其持续时间记为：wj,k
    则有：（1）e(i)=ve(j) (2) l(i)=vl(k)-wj,k
* 求关键路径的步骤
  * 求所有事件的最早发生时间ve()
    * 按`拓扑排序`序列，依次求各个顶点的ve(k)
    * ve(源点)=0
    * ve(k)=MAX{ve(j)+Weight(vj,vk)},vj为vk的任意前驱
  * 求所有事件的最迟发生时间vl()
    * 按`逆拓扑排序`序列，依次求各个顶点的vl(k)
    * vl(汇点)=ve(汇点)
    * vl(k)=Min{vl(j)-Weight(vk,vj)},vj为vk的任意后继
  * 求所有活动的最早发生时间e()
    * 若边<vk,vj>表示活动ai，则有e(i)=ve(k)
  * 求所有活动的最迟发生时间l()
    * 若边<vk,vj>表示活动ai，则有l(i)=vl(j)-Weight(vk,vj)
  * 求所有活动的时间余量d()
    * d(i)=l(i)-e(i)
* 关键活动、关键路径的特性
  * 若关键活动耗时增加，则整个工程的工期将增长
  * 缩短关键活动的时间，可以缩短整个工程的工期
  * 当缩短到一定程度时，关键活动可能会变成非关键活动
  * 可能有多条关键路径，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的
</details>