# :page_with_curl:图
## :one:图的定义和术语
**图的定义**
* 图
  * G=(V,E)
  * V：顶点（数据元素）的`有穷非空`集合
  * E：边的`有穷`集合

**术语**
* 无向图
  * 每条边都是无方向的
* 有向图
  * 每条边都是有方向的
* 完全图
  * 任意两个点都有一条边相连
  * 无向完全图，n(n-1)/2条边 ==Cn2==
  * 有向完全图，n(n-1)条边
* 稀疏图
  * 有很少边或弧的图（e<nlogn）
* 稠密图
  * 有较多边或弧的图
* 网
  * 边/弧带权的图
* 邻接
  * 有边/弧相连的两个顶点之间的关系
  * 存在(vi,vj)，则称vi和vj互为`邻接点`
  * 存在<vi,vj>，则称vi`邻接到`vj,vj`邻接与`vi
* 关联（依附）
  * 边/弧与顶点之间的关系
  * 存在(vi,vj)/<vi,vj>，则称该边/弧关联于vi和vj
* 顶点的度
  * 与该顶点相关联的边的数目，记为TD(v)
  * 在`有向图`中，顶点的度等于该顶点的`入度`和`出度`之和
  * 顶点`v的入度`是以v为终点的有向边的条数，记作ID(v)
  * 顶点`v的出度`是以v为始点的有向边的条数，记作OD(v)
    >当有向图中仅1个顶点的入度为0，其余顶点的入度均为1,此时是何形状？
    >>是树！且是一颗有向树！
* 路径
  * 接续的边构成的顶点序列
* 路径长度
  * 路径上边或弧的数目/权值之和
* 回路（环）
  * 第一个顶点和最后一个顶点相同的路径
* 简单路径
  * 除路径起点和路径终点可以相同外，其余顶点均不相同的路径
* 简单回路（简单环）
  * 除路径起点和终点相同外，其余顶点均不相同的路径
* 连通图（强连通图）
  * 在无（有）向图G={V,{E}}中，若对任何两个顶点v、u都存在从v到u的路径，则称G是连通图（强连通图）
* 权与网
  * 图中边或弧所具有的相关数称为权。表明一个顶点到另一个顶点的距离或耗费
  * 带权的图称为网
* 子图
  * 设有两个图G={G，{E}}、G1={V1，{E1}}，若V1是V的子集，E1是E的子集，则称G1是G的子图
* 连通分量（强连通分量）
  * 无向图G的`极大连通子图`称为G的连通分量
    * `极大连通子图`：该子图是G连通子图，将G的任何不在该子图中的顶点加入，子图不在连通
  * 有向图G的`极大强连通子图`称为G的强连通分量
    * `极大强连通子图`：该子图是G的强连通子图，将D的任何不在该子图中的顶点加入，子图不再是强连通的
* 极小连通子图
  * 该子图是G的连通子图，在该子图中删除任何一条边，子图不在连通
* 生成树
  * 包含无向图G所有顶点的极小连通子图
* 生成森林
    * 对非连通图，由各个连通分量的生成的树的集合
## :two:图的存储结构
**邻接矩阵**
* 建立一个`顶点表`（记录各个顶点的信息）和一个`邻接矩阵`（表示各个顶点之间的关系）
* 设图A=(V,E)有n个顶点则，顶点表`Vexs[n]`
* 图的邻接矩阵是一个二维数组`A.arxs[n][n]`,定义为
  * A.arcs[i][j]=
    * 1,如果<i,j>属于E或者(i,j)属于E
    * 0，否则
  >分析1：无向图的邻接矩阵是`对称`的
  分析2：顶点的`度`=第i行（列）中`1`的个数
  特别：完全图的邻接矩阵中，对角元素为0，其余1
****
* 有向图的邻接表示法
  * 在有向图的邻接矩阵中
    * 第i行的含义：以结点vi为尾的弧（即出度边）
    * 第i列的含义：以结点vi为头的弧（即入度边）
  >分析1：有向图的邻接矩阵`可能是不对称`的
  分析2：顶点的`出度=第i行元素之和`
  顶点的`入度=第i列元素之和`
  顶点的度=第i行元素之和+第i列元素之和
* 网（即有权图）的邻接矩阵表示法
  * A.arcs[i][j]=
    * wij ，<vi,vj>或(vi,vj)属于VR
    * 无穷 ，无边（弧）

**邻接矩阵的存储表示**
* 用`两个数组`分别存储`顶点表`和`邻接矩阵`
  ```c
  #define Maxint 32767     // 表示极大值
  #define MVNum 100        // 最大顶点数
  typedef char VerTexType; // 设顶点的数据类型为字符型
  typedef int ArcType;     // 假设边的权值类型为整型
  typedef struct
  {
      VerTexType vexs[MVNum];     // 顶点表
      ArcType arcs[MVNum][MVNum]; // 邻接矩阵
      int vexnum, arcnum;         // 图的当前点数和边数
  } AMGraph;
  ```
* 创建无向网的算法思想
  * 输入总顶点数和总边数
  * 依次输入点的信息存入顶点表中
  * 初始化矩阵，使每个权值初始化为最大值
  * 构造邻接矩阵
  ```c
  Status CreateUDN(AMGraph &G)
  {
      cin >> G.vexnum >> G.arcnum; // 输入总顶点数，总边数
      for (int i = 0; i < G.vexnum; i++)
          cin >> G.vexs[i]; // 依次输入点的信息
      for (int i = 0; i < G.vexnum; i++)
          for (int j = 0; j < G.vexnum; j++)
              G.arcs[i][j] = Maxint;     // 边的权值初始化极大值
      for (int k = 0; k < G.arcnum; k++) // 构造邻接矩阵
      {
          cin >> v1 >> v2 >> w; // 输入一条边所依附的顶点及边的权值
          int i = LocateVex(G, v1);
          int j = Locatevex(G, v2);    // 确定v1和v2在G中的位置
          G.arcs[i][j] = w;            // 边<v1,v2>的权值置为w
          G.arcs[j][i] = G.arcs[i][j]; // 利用对称性
      }
      return OK;
    
  int LocateVex(AMGraph G, VertexType u)
  {
      int i;
      for (int i = 0; i < G.vexnum; i++)
          if (u == G.vexs[i])
              return i;
      return -1;
  }
  ```