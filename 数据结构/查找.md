# :page_with_curl:查找
## :one:查找的基本概念
**几个问题**
* 在哪里找
  * `查找表`是由同一种类型的数据元素（或记录）构成的`集合`。由于集合中的数据元素之间存在着松散的关系，因此查找表是一种应用灵便的结构。
* 什么查找
  * 根据给定的某个值，在查找表中确定一个其`关键字`等于给定值的数据元素或（记录）
    * 关键字：用来标识一个数据元素（或记录）的某个数据项的值
      * 主关键字：可唯一标识一个记录的关键字是主关键字
      * 次关键字：反之，用以识别若干记录的关键字是次关键字
* 查找成功否
  * 若查找表中存在这样一个记录，则称`查找成功`
    * 查找结果给出整个记录的信息，或指示该记录在查找表中的位置
  * 否则称`查找不成功`
    * 查找结果给出`空记录`或`空指针`
* 查找目的是什么
  * 查询某个`特定的`数据元素是否在查找表中
  * 检索某个`特定的`数据元素的各种属性
  * 在查找表中插入一个数据元素
  * 删除查找表中的某个数据元素
* 查找表可分为两类
  * `静态查找表`：仅作查询（检索）操作的查找表
  * `动态查找表`：作插入和删除操作的查找表
    >有时在查询之后，还需要将查询结果为`不在查找表中`的数据元素`插入到`查找表中；或者，从查找表中`删除`其查询结果为`在查找表中`的数据元素，此类表为动态查找表
* 如何评价查找算法
  * 查找算法的评价指标：关键字的平均比较次数，也称`平均查找长度`ASL(Average Search Length)
* 查找过程中我们要研究什么
  * `查找的方法`取决于查找表的结构，即表中的数据元素是`依何种关系组织在一起的`
   >对于查找表来说，在集合中查询或检索一个特定的数据元素时，若无规律可循，只能对集合中的元素——加以辨认直至找到为止
   * 而样的查询或检索是任何计算应用系统中使用频度都很高的操作，因此`设法提高查找表的查找效率`
   * 为提高查找效率，一个办法就是在构造查找表时，`在集合中的数据元素之间人为地加上某种确定的约束关系`
## :two:线性表的查找
**顺序查找**
* 应用范围
  * 顺序表或线性链表表示的`静态查找表`
  * 表内元素之间无序
* 顺序表的表示
  * 数据元素定义
    ```c
    typedef struct
    {
        KeyType key; // 关键字域
        ....         // 其他域
    } ElemType;
    ```
  * 顺序表的结构定义
    ```c
    typedef struct // 顺序表结构类型定义
    {
        ElemType *R; // 表基址
        int length;  // 表长
    } SSTable;
    SSTable ST; // 定义顺序表ST
    ```
* 顺序查找
    ```c
    int Search_Seq(SSTable ST, KeyType key)
    {
        /*******写法一*******/
        for (i = ST.length; i >= 1; --i)
            if (ST.R[i].key == key)
                return i;
        return 0;
        /*******写法二*******/
        for (i = ST.length; ST.R[i].key != key; --i)
            if (i <= 0)
                break;
        if (i > 0)
            return i;
        else
            return 0;
        /*******变式*******/
        for (i = ST.length; ST.R[i].key != key && i > 0; --i)
            ;
        if (i > 0)
            return i;
        else
            return 0;
        /*******写法三*******/
        ST.R[0].key = key; // 引入哨兵，每次循环减少1次比较
        for (i = ST.length; ST.R[i].key != key; --i)
            ;
        return i;
    }
    ```
* 时间效率分析
  * 比较次数与key位置有关
    * 查找第i个元素，需要比较n-i+1次
    * 查找失败，需比较n+1次
  * 时间复杂度：O(n)
    * 查找成功时的平均查找长度，设表中各记录查找的概率相等
    * ASL=1/n * 累加i=1到n * (n-i+1)
    * ASL(n)=(1+2+...n)/n=(n+1)/2
  * 空间复杂度：一个辅助空间——O(1)
* 概率不确定
  * 记录的查找概率不相等时如何提高查找效率
    * 查找表存储记录原则——按查找概率高低存储
      * 查找概率越高，比较次数越小
      * 查找概率越低，比较次数越多
  * 记录的查找概率无法测定时如何提高查找效率
    * 方法——按查找概率动态调整记录顺序
      * 在每一个记录中设一个访问频度域
      * 始终保持记录按非递增有序的次序排列
      * 每次查找后均将刚查到的记录移至表头
* 顺序查找表的特点
  * 优点：算法简单，逻辑次序无要求，且不同存储结构均适用
  * 缺点：ASL太长，时间效率太低

**折半查找**
* 折半查找：每次将待查记录所在区间缩小一半
* 代码实现
    ```c
    int Search Bin(SSTable ST, KeyType key)
    {
        low = 1;
        high = ST.length; // 置区间初值
        while (low <= high)
        {
            mid = (low + high) / 2;
            if (ST.R[mid].key == key) // 找到待查元素
                return mid;
            else if (key < ST.R[mid].key) // 缩小查找区间
                high = mid - 1;           // 继续在前半区间进行查找
            else
                low = high + 1; // 继续在后半区间进行查找
        }
        return 0; // 顺序表中不存在待查元素
    }
    ```
    ```c
    // 递归实现
    int Search_Bin(SSTable ST, keytable key, int low, int high)
    {
        if (low > high)
            return 0; // 查找不到时返回0
        mid = (low + high) / 2;
        if (key == ST.elem[mid].key)
            return mid;
        else if (key < ST.elem[mid].key)
            Search_Bin(ST, key, low, mid - 1); // 递归在前半区查找
        else
            Search_Bin(ST, key, mid + 1, high); // 递归在后半区查找
    }
    ```