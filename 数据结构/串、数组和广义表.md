# :page_with_curl:串、数组和广义表
[:clock1:串](#one串)|[:clock2:数组](#two数组)|[:clock3:广义表](#three广义表)
---|---|---|
## :one:串
<details>
<summary> 

**串的定义**</summary>
* 零个或多个任意`任意字符组成的有限序列`
</details>

<details>
<summary>

**相关术语**</summary>
* 子串
  * 串中任意个连续字符组成的`子序列（含空串）`称为该串的`子串`
    * 例如，"abcde"的子串有："","a","ab","abc","abcd"和"abcde"等
    * `真子串`是指不包含自身的所有子串
* 主串
  * 包含子串的串相应地称为`主串`
* 字符位置
  * 字符`在序列中的序号`为该字符在串中的位置
* 子串位置
  * `子串第一个字符`在主串中的位置
* 空格串
  * 由一个或多个空格组成的串，`与空串不同`
* 串相等
  * 当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是`相等`的
  * 所有的空串是相等的
</details>
<details>
<summary>

**串的类型定义、存储结构及运算**</summary>
* 串的类型定义
    ```c
    ADT String{
        数据对象:D={ai | ai 属于 CharacterSet，i=1,2...n,n>=0}
        数据关系:R1={<ai-1,ai>|ai-1,ai属于D，i=1,2...n}
        基本操作:
        StrAssign (&T,chars) // 串赋值
        StrCompare(S,T) // 串比较
        StrLength(S) // 求串长
        Concat(&T,S1,S2)  // 串连接
        .....
    }ADT String
    ```
* 串的存储结构
  * 串的顺序存储结构
    ```c
    #define MAXLEN 255
    tyepdef struct
    {
        char ch[MAXLEN+1]; // 存储串的一维数组
        int length; // 串的当前长度
    }SString;
    ```  
  * 串的链式存储结构
    * 优点：操作方便
    * 缺点：存储密度低
    * 克服缺点：将多个字符放在一个节点中，以克服其缺点
    * 块链结构
        ```c
        #define CHUNKSIZE 80
        typedef struct Chunk
        {
            char ch[CHUNKSIZE];
            struct Chunk *next;
        }Chunk;
        typedef struct
        {
            Chunk *head,*tail; // 串的头指针和尾指针
            int curlen; // 串的当前长度
        }Lstring; // 字符串的块链结构
        ```
* 串的模式匹配算法
  * 算法目的
    * 确定`主串`中所含`子串（模式串）`第一次出现的位置（定位）
  * 算法应用
    * 搜索引擎、拼写检查、语言翻译、数据压缩
  * 算法种类
    * BF算法（Brute-Force，暴力破解法）
    * KMP算法（特点：速度快）
  * 算法设计思想 `Index(S,T,pos)`
    * 将主串的第pos个字符和模式串的第一个字符比较
      * 若相等，继续逐个比较后续字符
      * 若不等，从主串的下一字符起，重新与模式串的第一个字符比较
    * 直到主串的一个连续字符序列与模式串相等。返回值为S中与T匹配的子序列第一个字符的序号，即匹配成功
    * 否则，匹配失败，返回值0
  * 算法实现
    ```c
    int Index_BF(SString S, SString T)
    {
        int i = 1, j = 1;
        while (i <= S.length && j <= T.length)
        {
            if (s.ch[i] == t.ch[j]) // 主串和子串依次匹配下一个字符
            {
                ++i;
                ++j;
            }
            else // 主串、子串指针回溯重新开始下一次匹配
            {
                i = i - j + 2;
                j = 1;
            }
        }
        if (j >= T.length) // 返回匹配的第一个字符的下标
            return i - T.length;
        else
            return 0; // 模式匹配不成功
    }
    ```
      * BF算法时间复杂度
      * 若n为主串长度，m为子串长度，最坏情况是
        * 主串前面n-m个位置都部分匹配到子串的最后一位，即这n-m位各比较了m次
        * 最后m位也各比较了1次
        > 总次数为：`(n-m)*m+m=(n-m+1)*m`
        > 若m<<n,则算法复杂度为`O(n*m)`
    * KMP算法
      ```c
      int index_KMP(SString S, SString T, int pos)
      {
          i = pos, j = 1;
          while (i <= S.length && j <= length)
          {
              if (j == 0 || S.ch[i] == T.ch[j])
              {
                  i++;
                  j++;
              }
              j = next[j];
          }
          if (j > T.length)
              return i - T.length;
          else
              return 0;
      }
      ```  
    * next函数的求法
      ```c  
      void get_next(SString T, int next[])
      {
          i = 1;
          next[1] = 0;
          j = 0;
          while (i < T.length)
          {
              if (j == 0 || T.ch[i] == T.ch[j])
              {
                  ++i;
                  next[i] = j;
                  ++j;
              }
              else
                  j = next[j];
          }
      }
      ```
      ```c
      自定义写法
      void get_next(SString T, int next[])
      {
          next[1] = 0;
          next[2] = 1;
          int i = 2;
          while (i < length)
          {
              if (T.ch[i] == T.ch[next[i]])
              {
                  next[++i] = next[i] + 1;
              }
              else
              {
                  if (T.ch[i] == T.ch[1])
                  {
                      next[++i] = 2;
                  }
                  else
                  {
                      next[++i] = 1;
                  }
              }
          }
      }
      ```
    * nextval的求法
      ```c
      void get_nextval(S T, int nextval[])
      {

          int i = 1;
          nextval[1] = 0;
          int j = 0;
          while (i < T.length)
          {
              if (j == 0 || T.ch[i] == T.ch[j])
              {
                  ++i;
                  ++j;
                  if (T.ch[i] != T.ch[j])
                  {
                      nextval[i] = j;
                  }
                  else
                      nextval[i] = nextval[j];
              }
              else
                  j = nextval[j];
          }
      }
      ```
      ```c
      自定义写法（复杂度较高）
      void get_nextval(S T, int nextval[])
      {
          int i = 1;
          nextval[1] = 0;
          int j = 0;
          while (i < T.length)
          {
              if (j == 0 || T.ch[i] == T.ch[j])
              {
                  ++i;
                  ++j;
                  nextval[i] = j;
              }
              else
                  j = nextval[j];
          }
          for (int i = 2; i <= T.length; i++)
          {
              if (T.ch[i] == T.ch[nextval[i]])
              {
                  nextval[i] = nextval[nextval[i]];
              }
          }
      }
      ```
      </details>

## :two:数组
<details>
<summary>

**数组的定义**</summary>
* 数组：按一定格式排列起来的具有`相同类型`的数据元素的集合
****
* 一维数组：若线性表中的数据元素为非结构的简单元素，则称为一维数组
* 一维数组的逻辑结构：`线性结构`。定长的线性表
* 声明格式： 数据类型 变量名称[长度]
****
* 二维数组：若一维数组中的数据元素又是一维数组结构，则称为二位数组
* 二维数组的逻辑结构：
  * 非线性结构：每一个数据元素既在一个行表中，又在一个列表中
  * 线性结构，定长的线性表：该线性表中的每个数据元素也是一个定长的线性表
  * 声明格式：数据类型 变量名称[行数][列数]
  * 在c语言中，一个二位数组类型也可以定义为一位数组类型
    ```c
    typedef elemtype array2[m][n]
    等价于
    typedef elemtype array1[n];
    typedef array[1] array2[m];
    ```
****
* 三维数组：若二维数组中的元素又是一个一维数组，则称为三维数组
* n维数组：若n-1维数组中的元素又是一个一位数组结构，则称为n维数组
* 数组特点：`结构固定`——定义后，维数和维界不再改变
* 数组结构：除了结构的初始化和销毁之外，只有取元素和修改元素值的操作
</details>
<details>
<summary>

**数组的顺序存储结构**</summary>
* 因为
	* 数组特点：`结构固定`—维数和维界不变
	* 数组的基本操作：初始化、销毁、取元素、修改元素值一般不做插入和删除操作
* 所以
	* 采用`顺序存储结构`来表示数组
* 注意
	* 数组可以是多维的，但存储数据元素的内存单元地址是一维的，因此，在存储数组结构之前，需要解决多维关系映射到一维关系的问题
****
* 一维数组
	* LOC(i)
		* LOC(0)=a,i=0
		* LOC(i-1)+L=a+i*L,i>0
* 二维数组
存储单元是`一维`结构，而数组是个`多维`结构，则用一组连续存储单元存放数组的数据元素就有个`次序约定`问题
> 有二维数组A[m][n]
 以行序为主序:设数组开始存储位置LOC(0,0),存储每个元素需要L个存储单元，数据元素a[i][j]的存储位置是LOC(i,j)=LOC(0,0)+(n*i+j)*L
* 三维数组
>a[m1][m2][m3]各维元素个数为m1,m2,m3
>下标i1，i2，i3的数组元素的存储位置
>LOC(i1,i2,i3)=a+i*m2*m3+i2*m3+i3
</details>
<details>
<summary>

**特殊矩阵的压缩存储**</summary>
>* 什么是`压缩存储`
	若多个数据元素的`值都相同`，则只分配一个元素值的存储空间，且零元素不占用存储空间
>* 什么样的矩阵能够压缩
一些特殊矩阵，如：对称矩阵，三角矩阵，稀疏矩阵等
>* 什么叫稀疏矩阵
	矩阵中零元素的个数较少（一般小于5％）
* 对称矩阵
特点：在n＊n的矩阵a中，满足以下性质
`aij=aji(1<=i,j<=n)`
存储方法：只存储下（或者上）三角（包括主对角）的数据元素。共占用n*(n+1)/2个元素空间
存储结构：对称矩阵上下三角中的元素数均为：n(n+1)/2
可以将`以行序为主序`将元素存放在一个一维数组sa[n(n+1)/2]中
* 三角矩阵
特点：对角线以下（或者以上）的数据元素（不包括对角线）全部为常数c
存储方法：重复元素c共享一个元素存储空间，共占用n(n+1)/2+1个元素
上三角矩阵：
k=
(i-1)*(2n-i+2)/2+j-i+1, i<=j
n(n+1)/2+i,i>j
下三角矩阵：
k=
i(i-1)/2+j,i>=j
n(n+1)/2+1,i<j
* 对角矩阵
特点：在n*n的方阵中，所有非零元素都集中集中在以主对角线为中心的带状区域中，区域外的值全为0，则称为对角矩阵。常见的有三对角矩阵、五对角矩阵、七对角矩阵等
存储方法：以对角线的顺序存储存放在一个二维数组
主对角线为中心
* 稀疏矩阵
 特点：在设在m * n的矩阵中有t个非零元素。令 &=t/(m*n),当&<=0.05时称为稀疏矩阵
 压缩存储原则（三元组）：存各非零元素的值、行列位置和矩阵的行列数
	> 三元组顺序表又称为`有序的双下标法`
	 三元组顺序表的`优点`：非零元素在表中按行序有序存储，因此`便于进行依行顺序处理的矩阵运算`
	 三元组顺序表的缺点：不能随机存取，若按行号存取某一行中的非零元，则需从头开始查找
	 
	稀疏矩阵的链式存储结构：十字链表
	* 优点：能够`灵活地插入`因运算而产生的新的非零元素。`删除`因运算而产生的新的零元素，实现矩阵的各种运算
	* 在十字链表中，矩阵的每一个非零元素用一个节点表示，该节点除了（row，col，value）以外，还要有两个域
		* right：用于链接同一行中的下一个非零元素
		* down：用于链接同一列中的下一个非零元素
</details>

## :three:广义表
<details>
<summary>

**定义**</summary>
* 广义表（又称列表Lists）是n>=0个元素a0，a1,......an-1的有限序列，其中每一个ai或者`原子`，或者是一个`广义表` 
* `广义表`通常记作：LS＝（a1,a2...an）
	* 其中：LS为`表名`，n为`表的长度`，每一个ai为`表的元素`
	* 习惯上，一般用`大写字母`表示`广义表`，`小写字母`表示`原子`
* `表头`：若LS非空（n>=1）,则其中`第一个元素`a1就是表头。记作`head(LS)＝a1`.注：表头可以是原子，也可以是子表
* `表尾`：除表头之外的`其他元素`组成的`表`。记作`tail(LS)=(a2,..an)`。注：表尾不是最后一个元素，而是一个子表
</details>
<details>
<summary>

**性质**</summary>
* 广义表中的数据元素有相对`次序`;`一个直接前驱和一个直接后继`
* 广义表的`长度`定义为最外层所包含元素的个数；如：C=(a,(b,c))是长度为2的广义表
* 广义表的`深度`定义为该广义表`展开后括号的重数`。A=(b,c)的深度为1，B＝(A,d)的深度为2，C=(f,B,h)的深度为3
	* 注意："原子"的深度为0，“空表”的深度为1
* 广义表可以为其他广义表`共享`；如；广义表B就共享表A，在B中不必列出A的值，而是通过名称来引用，B＝(A)
* 广义表可以是一个`递归`的表。如：F=(a,F)=(a,(a(a(.....))))
	* 注意：递归表的深度是无穷值，长度是有限值
* 广义表是`多层次`结构，广义表的元素可以是单元素，也可以是子表，而子表的元素还可以是子表
</details>
<details>
<summary>

**基本运算**</summary>
* 求表头GetHead(L)：非空广义表的第一个元素，可以是一个原子，也可以是一个子表
* 求表尾GetTail(L)：非空广义表除去表头元素以外其他元素所构成的一个表。表尾一定是一个表
  ```
  例：D=(E,F)=((a,(b,c)),F)
  GetHead(D)=E,GetTail(D)=(F)
  GetHead(E)=a,GetTail(E)=((b,c))
  GetHead(((b,c)))=(b,c),GetTail(((b,c)))=()
  GetHead((b,c))=b,GetTail((b,c))=(c)
  GetHead((c))=c,GetTail((c))=()
  ```
  </details>